-- profiles table
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  updated_at TIMESTAMPTZ,
  username TEXT UNIQUE,
  full_name TEXT,
  avatar_url TEXT,
  website TEXT,
  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Function to create a profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username)
  VALUES (new.id, new.email);
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function on new user creation
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- daily_pages table
CREATE TABLE public.daily_pages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  page_date DATE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (user_id, page_date)
);

ALTER TABLE public.daily_pages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own daily pages." ON public.daily_pages
  FOR ALL USING (auth.uid() = user_id);

-- todos table
CREATE TABLE public.todos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  daily_page_id BIGINT NOT NULL REFERENCES public.daily_pages(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- pending, in_progress, done
  priority INT DEFAULT 1, -- 1: low, 2: medium, 3: high
  memo TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE public.todos ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own todos." ON public.todos
  FOR ALL USING (auth.uid() = (
    SELECT user_id FROM public.daily_pages WHERE id = daily_page_id
  ));

-- transactions table
CREATE TABLE public.transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  daily_page_id BIGINT NOT NULL REFERENCES public.daily_pages(id) ON DELETE CASCADE,
  amount NUMERIC(15, 2) NOT NULL,
  currency VARCHAR(3) NOT NULL, -- KRW, USD
  type TEXT NOT NULL, -- income, expense
  category TEXT,
  memo TEXT,
  exchange_rate_snapshot NUMERIC(15, 6),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own transactions." ON public.transactions
  FOR ALL USING (auth.uid() = (
    SELECT user_id FROM public.daily_pages WHERE id = daily_page_id
  ));

-- exchange_rates table
CREATE TABLE public.exchange_rates (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  rate_date DATE NOT NULL,
  from_currency VARCHAR(3) NOT NULL,
  to_currency VARCHAR(3) NOT NULL,
  rate NUMERIC(15, 6) NOT NULL,
  UNIQUE(rate_date, from_currency, to_currency)
);

-- This table is public and doesn't need RLS for reads.
-- For writes, you might want to restrict it to a service role key.
ALTER TABLE public.exchange_rates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Exchange rates are viewable by everyone." ON public.exchange_rates FOR SELECT USING (true);
-- Add a policy for inserts/updates if you plan to update rates via the API.
-- For example, allowing only a service_role to insert. It's safer to do this from a backend function.